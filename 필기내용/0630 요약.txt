0630 요약
* 기존코드
- 개수를 알기 위해서 3번 스크립트 실행 => 개수 몰라도 실행 가능하게 해야함(객체지향)
- 링크드 리스트 사용!

* 링크드 리스트
- 나는/철수/입니다 => 1개 문단, 3개의 문장
- 기존 : 3개를 먼저 알고 난 후, 문단에 내용 저장
- 현재 : 개수를 모르는 상태로 문단에 내용 저장
- start : 첫 문장, current : 현재 문장
- 읽은 시점에서 현재 문장 x
-> 현재 문장 : 나는 / 첫 문장 나는 (null 나는 null)
- 읽은 시점에서 다음 문장 있음 -> 현재문장 : 나는 / 첫 문장 : 나는 (null 나는 <-> 철수 null)
- 읽은 시점에서 다음 문장 있음 -> 현재 문장 : 철수 / 첫 문장 : 나는 (null 나는 <-> 철수 <-> 입니다 null)
- 출력 할 때
-> 첫 문장의 위치를 알고 있음 => 첫 문장의 next를 출력함
current = start일 때, '나는'이 들어가 있음
current = current->next로 바꾸면 '철수'가 들어가 있음
current = current->next로 바꾸면 '입니다'가 들어가 있음
current = current->next로 바꾸면 null => 프로그램 종료

* 가장 많이 쓰이는 것 : 배열, 링크드리스트, 스택 등등
- 배열 : 임의 접근 가능(주어진 개수 내에서는 어디에 접근하나 속도가 같음), 중간에 삽입 삭제가 불편함
- 링크드 리스트 : 접근 전까지 있는지 확인 불가능 // 임의 접근 불가능 , 중간에 삽입 삭제 등 편리함 

* GitHub
- git init : 저장소 생성
- push, pull 공부하기 + clone
- https://github.com/kooa77/weekly_textadv_oop // 선생님 저장소
-> 다운이 목적이 아닌 서로의 작업을 똑같이 만들기 위해 하는 것(동기화!)
+) commit으로 저장(Tortoise 설치?) -> push

* 객체지향
- 캡슐화 : 누가 누구껀지 확실히 알기 위해 이름을 잘 정의해줘야 함!
(m_ or _ : 어떤 구조체의 멤버 변수임을 알려줌)
- 객체 : 데이터+함수
- programmer -> data
	     -> fx (절차지향)
- programmer -부탁-> 객체 -> data
	 		  -> fx (객체지향)
- 이름을 추상적으로 변환함
- 어떤 객체에 데이터+함수 존재할 때, 허용은 public / 비허용은 private
- class 기본은 private로 선언됨 => 객체지향은 허락없이 바꿀 수 없음
- class와 구조체의 차이 -> class는 private / 구조체는 public이 기본 설정
- 객체지향에서는 물리적으로 격리하는것까지 권장 -> 새로운 소스코드로 설정
(일반적으로 하나의 클래스는 하나의 파일) -> 자바,C#은 자동 생성됨
- .cpp에서는 헤더파일 인클루드, .h에서는 최대한 사용 자제하기(전방 선언(전역 변수) 등으로 해결하기 => 나중에 꼬일수 있음)
- 데이터는 닫고(private), 기능은 오픈(public)
- 기능을 알기 위한 문서 -> 레퍼런스(객체가 커지면 데이터와 기능이 증가해서 무슨 내용이 있는지를 모르기 때문에 필요)
- 멤버변수를 받아오려면 getter함수, 수정하려면 setter함수 사용해야 함